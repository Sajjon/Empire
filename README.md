[![Build Status][build status badge]][build status]
[![Platforms][platforms badge]][platforms]
[![Documentation][documentation badge]][documentation]

# Empire

A record store for Swift

Empire is an experiment in persistence.

- Schema is defined by your types
- Macro-based API that is both typesafe and low-overhead
- Built for Swift 6 
- Backed by a sorted-key index data store ([LMDB][LMDB])

> [!CAUTION]
> This is still a WIP. Lots of stuff doesn't work right.

```swift
import Empire

@IndexKeyRecord("name")
struct Person {
    let name: String
    let age: Int
}

let store = try Store(path: "/path/to/store")

try await store.withTransaction { ctx in
    try ctx.insert(Person(name: "Korben", age: 45))
    try ctx.insert(Person(name: "Leeloo", age: 2000))
}
	
let records = try await store.withTransaction { ctx in
    try Person.select(in: ctx, name: .lessThan("Zorg"))
}

print(record.first!) // Person(name: "Leeloo", age: 2000)
```


## Integration

```swift
dependencies: [
    .package(url: "https://github.com/mattmassicotte/Empire", branch: "main")
]
```

## Data Modeling and Queries

Empire uses a data model that is **extremely** different from a traditional SQL-backed data store. It is pretty unforgiving and can be a challenge, even if you are familiar with it.

Conceptually, you can think of every record as being split into two tuples: the "index key" and "fields". Queries are **only** possible on components of the index key. Further, the ordering of key components matters. Only the last component of a query can be a non-equality comparison. If you want to look for a range of a key component, you must restrict all previous components.

```swift
@IndexKeyRecord("lastName", "firstName")
struct Person {
    let lastName: String
    let firstName: String
    let age: Int
}
```

The arguments to the `@IndexKeyRecord` macro define the properties that make up the primary key. Critically, your types **are** the schema. The type's data is serialized directly to binary using code generated by the macro. Making changes to your types will make deserialization of unmigrated data fail.

```swift
// scan query on the first component
store.select(lastName: .greaterThan("Dallas"))

// constrain first component, scan query on the second
store.select(lastName: "Dallas", firstName: .lessThanOrEqual("Korben"))

// ERROR: an unsupported key arrangement
store.select(lastName: .lessThan("Zorg"), firstName: .lessThanOrEqual("Jean-Baptiste"))
```

The code generated for a `@IndexKeyRecord` type makes it a compile-time error to write invalid queries.

As a consequence of a limited query capability, you must model your data by starting with the queries you need to support. This can require denormalization, which may or may not be appropriate for your expected number of records.

## Questions

### Why does this exist?

I'm not sure! I haven't used [CoreData](https://developer.apple.com/documentation/coredata) or [SwiftData](https://developer.apple.com/documentation/swiftdata) too much. But I have used the distributed database [Cassandra](https://cassandra.apache.org) quite a lot and [DynamoDB](https://aws.amazon.com/dynamodb/) a bit. Then one day I discovered [LMDB][LMDB]. Its data model is quite similar to Cassandra and I got interested in playing around with it. This just kinda materialized from those experiments.

### Can I use this?

Sure!

### *Should* I use this?

User data is important. This library has a bunch of tests, but it has no real-world testing. I plan on using this myself, but even I haven't gotten to that yet. It should be considered *functional*, but experimental.

## Contributing and Collaboration

I'd love to hear from you! Get in touch via [mastodon](https://mastodon.social/@mattiem), an issue, or a pull request.

I prefer collaboration, and would love to find ways to work together if you have a similar project.

I prefer indentation with tabs for improved accessibility. But, I'd rather you use the system you want and make a PR than hesitate because of whitespace.

By participating in this project you agree to abide by the [Contributor Code of Conduct](CODE_OF_CONDUCT.md).

[build status]: https://github.com/mattmassicotte/Empire/actions
[build status badge]: https://github.com/mattmassicotte/Empire/workflows/CI/badge.svg
[platforms]: https://swiftpackageindex.com/mattmassicotte/Empire
[platforms badge]: https://img.shields.io/endpoint?url=https%3A%2F%2Fswiftpackageindex.com%2Fapi%2Fpackages%2Fmattmassicotte%2FEmpire%2Fbadge%3Ftype%3Dplatforms
[documentation]: https://swiftpackageindex.com/mattmassicotte/Empire/main/documentation
[documentation badge]: https://img.shields.io/badge/Documentation-DocC-blue
[LMDB]: https://www.symas.com/lmdb
